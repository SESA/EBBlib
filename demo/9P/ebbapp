#!/bin/bash
#set -x
######
#
#  Boston University 
#
#  Scalable Elastic Systems Architecture (SESA)
#  Simple demo launch script to start worker nodes
#  from a front end node
#
#####

# Global configuration settings
declare -x -r BASEDIR="${EBBAPP_BASEDIR:-$(dirname $(type -p -a ebbapp))}"
declare -x -r LOCKDIR=${BASEDIR}/locks
declare -x -r P9CMD="$BASEDIR/bin/ixpc" 
declare -x -r P9SRV="$BASEDIR/bin/ufs"
declare -x -r EBBFSPORT=12345
declare -x -r NODEIDFILE=${BASEDIR}/NodeId
declare -x -r NODEIDSTART=1
declare -x -r NODEIDEND=1000000
#declare -x -r SINGLESERVER=12345

# Global Variables
declare -x -i verbose=0
# app/server/frontend info
declare -x appid
declare -x appip
declare -x appport=${SINGLESERVER}
declare -x appaddr
declare -x appdir
declare -x apppid
declare -x -i appstart=0

# node info
declare -x nodeip
declare -x nodeid
declare -x nodeport=${EBBFSPORT}
declare -x nodeaddr
declare -x nodedir


function usage
{
  echo "USAGE: $(basename $0) [-h] [-v] [-a appid] [-i <frontend ip>]" \
       "<nodeip> 
         -h help
         -v verbose
         -a existing appid: if specified node will be added
         -i explicit ip address of frontend to be used" > /dev/stderr
  exit -1
}

function ERROR
{
    printf "ERROR: $*\n" > /dev/stderr
    usage 
}

function VERBOSE
{
  ((verbose > 0)) && printf "$*\n" > /dev/stderr
}

function genport
{
  local -i v=$(( 49152 + ($RANDOM % (65535 - 49152)) ))
  local ip=$1

  while true; do
      ( echo "hello" > /dev/tcp/$ip/$v ) 2> /dev/null
      if [[ $? = 0 ]]
      then
	(( v=$RANDOM + 49152 ))
      else
        break;
      fi
  done

  printf $v
}

function killchildren 
{
  VERBOSE "killchildren : $1"
  ppid=$1
  if [[ -z $ppid ]]
  then
    ppid=$$
  fi
  children="$(ps --ppid $ppid -o pid --no-headings)" 
  for pid in "$children"
  do
    if [[ -n $pid ]]
    then
      VERBOSE "killing $pid"
      kill -9 $pid > /dev/null 2>&1
    fi
  done
}

function cleanup
{
   VERBOSE cleanup
   killchildren
}

function myIPAddrs
{
   local net
   local ip
   local rest
   local rc

   # If no argument all configured ip address are returned
   # otherwise only for the speccified interface
   ifconfig $1 2> /dev/null | grep -i 'inet.*mask' | while read net ip rest
   do
     ip=${ip##addr:}
     if [[ $ip != 127.0.0.1 ]]
     then
        echo $ip
     fi
   done
}

function myInterfaces
{
   local iface
   local rest

   ifconfig | grep Link | while read iface rest
   do
      echo $iface
   done
}

function interfaceAddr
{
  local iface
  local ip

  if [[ -z $1 ]]
  then
    echo "USAGE: internfaceAddr <ip>" >&2
    return -1
  fi

  for iface in $(myInterfaces) 
  do
      ip=$(ifconfig $iface | grep 'inet addr')
      ip=${ip#*:}
      ip=${ip%% *}
      if [[ $ip = "$1"* ]]
      then
        echo $iface
        return 0
      fi
  done

  return -1
}

function lock
{
    local lockname=$1
    local lockfile=$LOCKDIR/${lockname}.lock

    if [[ -z $lockname ]]
    then
      echo "USAGE: $FUNCNAME <lock>"  >&2
      return -1
    fi

    if [[ ! -d $LOCKDIR ]]
    then
      if ! mkdir -p $LOCKDIR
      then
         echo "ERROR: $FUNCNAME: $LOCKDIR does not exist "\
              "and cannot be created" >&2
         exit -1
      fi
    fi

    # Acquire lock
    lockfile -s1 $lockfile
    touch $lockfile
}

function unlock
{
    local lockname=$1
    local lockfile=$LOCKDIR/${lockname}.lock

    if [[ -z $lockname ]]
    then
      echo "USAGE: $FUNCNAME <lock>"  >&2
      return -1
    fi
    # Release lock
    rm -f $lockfile
}

#
# FIXME: This does not handle roleover and not sure it behaves well
#        with really big allocs
#
getNodeId()
{
  local rc

  lock nodeids
    if [[ ! -e $NODEIDFILE ]]
    then
       echo $NODEIDSTART > $NODEIDFILE
    fi
    rc=$(cat $NODEIDFILE)
    if (( $rc == $NODEIDEND )) 
    then
       unlock nodeids
       echo "ERROR: locked_getNewConID: last id reached: NYI" >&2
       return -1
    fi
    echo $(( $rc + 1 )) > $NODEIDFILE

  unlock nodeids

  echo $rc
  return 0
}

locked_getNewPNetIDs()
{
  local num=$1
  local rc

  if [[ -z $num ]]
  then
    num=1
  fi

  if [[ ! -e $KHPNETIDFILE ]]
  then
     echo $KHPNETIDSTART > $KHPNETIDFILE
  fi

  rc=$(cat $KHPNETIDFILE)

  if (( ($rc + ($num-1)) > $KHPNETIDEND ))
  then
     echo "ERROR: locked_getNewPNetIDs: not enough id : NYI" >&2
     return -1
  fi
  echo $(( $rc + $num )) > $KHPNETIDFILE

  if (( $num > 1 ))
  then
    eval echo {${rc}..$(( $rc + ($num-1) ))}
  else
    echo $rc
  fi

  return 0
}

function connectToNode
{
   local -i cnt=100
   local -i alive=-1

   while (( cnt > 0 )); do
      ping -c 1 $nodeip > /dev/null 2>&1
      alive=$?
      (( alive == 0 )) && break;
      (( cnt-- ))
      sleep 1
      echo -n "."
   done

   if (( alive == 0 )) 
   then
       alive=-1
       VERBOSE "$nodeid: $nodeip is up"
       echo "c ${appaddr} ${nodedir} ${nodeid}" | $P9CMD -a "${nodeaddr}" write cmd
       cnt=100
       VERBOSE "$nodeid: waiting stdout, err and in to appear ..."
       while (( cnt > 0 )); do
          if [[ -r ${nodedir}/stdout && -r ${nodedir}/stderr && -w ${nodedir}/stdin ]]; then
	      (( alive=0 ))
	  fi
          (( alive == 0 )) && break;
	  (( cnt-- ))
	  sleep 1
          echo -n "."
       done
       if (( alive == 0 )); then VERBOSE "$nodeid: appears to be alive"; fi
   fi

   echo "r" | $P9CMD -a "${nodeaddr}" write cmd

   return $alive
}

function processArgs
{
  local    origargs="$@"
  local -i optcount=0
  
  while getopts "a:i:vh" OPT; do 
    case $OPT in
      ("h") usage; exit -1;;
      ("a") appid="$OPTARG"; (( optcount+=2 ));;
      ("i") appip="$OPTARG"; (( optcount+=2 ));;
      ("v") verbose=1;(( optcount+=1 ));;
    esac
  done

  shift $optcount
  nodeip=$1

  if [[ -z $nodeip ]]; then
    ERROR "must specify node"
  fi
 
  if [[ -z $appip ]]; then 
      appip="$(myIPAddrs)"
      appip=${appip%% *}
  fi

  if [[ -z $appid ]]; then
    if [[ -z $appport ]]; then appport=$(genport $appip); fi
    appid=${appport}.$$
    (( appstart=1 ))
  else 
    appport=${appid%%.*}    
  fi
  appaddr="tcp!${appip}!${appport}"
  appdir=${BASEDIR}/$appid

  nodeaddr="tcp!${nodeip}!${nodeport}"
  nodeid=$(getNodeId)
  nodedir=$appdir/nodes/${nodeid}_${nodeip}
}

function setupDirs
{
  if [[ -d $appdir ]] || ! mkdir -p $appdir 
  then
    ERROR "Not able to create $appdir"
  fi

  if [[ -d $nodedir ]] || ! mkdir -p $nodedir 
  then
    ERROR "Not able to create $nodedir"
  fi
}

function startServer
{
  (cd $appdir && exec $P9SRV -p $appport -s) &
  apppid=$(jobs -p %%) 
  echo "$apppid" > $appdir/pid
}

function sanitycheck
{
    if [[ ! -x $P9CMD ]]; then
	ERROR "Cannot find $P9CMD"
    fi

    if [[ ! -x $P9SRV ]]; then
	ERROR "Cannot find $P9SRV"
    fi

    if ! type -a lockfile > /dev/null 2>&1; then
       ERROR "Cannot find lockfile in your path"
    fi
}

# main()
trap cleanup SIGHUP 
trap cleanup SIGTRAP 
trap cleanup SIGKILL 
trap "" SIGCHLD 
trap cleanup SIGQUIT 
trap cleanup SIGINT 
trap cleanup SIGABRT 
trap "" EXIT
trap "" SIGTERM

sanitycheck
 
processArgs $@

setupDirs

(( appstart == 1 )) && startServer

VERBOSE "appid=${appid} appip=${appip} appport=${appport} appaddr=${appaddr} appdir=${appdir} appstart=${appstart} apppid=${apppid}"   
VERBOSE "nodeid=${nodeid} nodeip=${nodeip} nodeport=${nodeport} nodeaddr=${nodeaddr} nodedir=${nodedir}"

connectToNode

(( appstart == 1 )) && wait

VERBOSE "ebbapp $appid terminated"
cleanup
