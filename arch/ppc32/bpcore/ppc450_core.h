/* begin_generated_IBM_copyright_prolog                             */
/*                                                                  */
/* This is an automatically generated copyright prolog.             */
/* After initializing,  DO NOT MODIFY OR MOVE                       */
/*  --------------------------------------------------------------- */
/*                                                                  */
/* (C) Copyright IBM Corp.  2007, 2007                              */
/* IBM CPL License                                                  */
/*                                                                  */
/*  --------------------------------------------------------------- */
/*                                                                  */
/* end_generated_IBM_copyright_prolog                               */
/**
 * \file bpcore/ppc450_core.h
 */

#ifndef _PPC450_CORE_H_ // Prevent multiple inclusion
#define _PPC450_CORE_H_



#include <arch/ppc32/common/namespace.h>
#include <arch/ppc32/common/bgp_bitnumbers.h>

__BEGIN_DECLS

#define _BGP_NUM_CORES (4)

//@MG: TODO: measure the MAXFLUSH break-even points in the VHDL simulator

// PPC450 32K Level 1 I-Cache: Virtual Tag = A[0..22], Set = A[23..26]
#define L1I_CACHE_LINES           1024 // 64 ways of 16 sets per way
#define L1I_CACHE_LINE_SIZE         32 // 8 words
#define L1I_CACHE_MASK      0xFFFFFFE0 // mask for 32 byte alignment
#define L1I_CACHE_MAXFLUSH         512 // above this num lines, invalidate the whole thing
#define L1I_CACHE_BYTES    (L1I_CACHE_LINES * L1I_CACHE_LINE_SIZE)

// PPC450 32K Level 1 D-Cache: Physical Tag = A[0..22], Set = A[23..26]
#define L1D_CACHE_LINES           1024 // 64 ways of 16 sets per way
#define L1D_CACHE_LINE_SIZE         32 // 8 words
#define L1D_CACHE_MASK      0xFFFFFFE0 // mask for 32 byte alignment
#define L1D_CACHE_MAXFLUSH         512 // above this num lines, use fast flush-assist
#define L1D_CACHE_BYTES    (L1D_CACHE_LINES * L1D_CACHE_LINE_SIZE)
#define L1D_CACHE_ASSOC             64 // L1-D is 64-way set-associative
#define L1D_CACHE_WAYS              64 // L1-D has 64 ways in each set
#define L1D_CACHE_SETS              16 // L1-D has 16 sets

// Define L1-D's Internal Organization
#define _L1D_ADDR_TAG(x)             _B23(22,x)     // Bits  0-22 are the Address Tag
#define _L1D_ADDR_SET(x)             _B4(26,x)      // Bits 23-26 are the Set Index
#define _L1D_ADDR_OFFSET(x)          _B5(31,x)      // Bits 27-31 is the Line Offset


#define SPRN_CCR0        0x3B3      // Core Configuration Register
#define   CCR0_PRE      _BN(1)      //   D-Cache Parity Error Recoverability Enable (0=semi, 1=fully)
#define   CCR0_CPRE     _BN(4)      //   Cache Read Parity Enable (0=like Stealth, 1=Enables (I/D)CDBTR(H/L))
#define   CCR0_DSTG     _BN(10)     //  Disable Store Gathering
#define   CCR0_DAPUIB   _BN(11)     //  Disable APU Instruction Broadcast (Turns off Hummer)
#define   CCR0_DTB      _BN(16)     //  Disable Trace Broadcast
#define   CCR0_GICBT    _BN(17)     //  Guaranteed Instructiton Cache Block Touch
#define   CCR0_GDCBT    _BN(18)     //  Guaranteed Data Cache Block Touch
//mtn#define   CCR0_Rsvd_BHT _BN(19)     //  Special Branch History Initialization, enables Uncond Br's to update BHT
#define   CCR0_FLSTA    _BN(23)     //  Force Load/Store Alignment
//mtn#define   CCR0_BHT_DIS  _BN(24)     //  Disable the Branch History Table
//mtn#define   CCR0_BTAC_DIS _BN(25)     //  Disable the Branch Target Address Cache
#define   CCR0_ICSLC(x) _B2(29,x)   // Instruction Cache Speculative Line Count (number of additional lines to fill on i-cache miss (0-3)
#define   CCR0_ICSLT(x) _B2(31,x)   // Instruction Cache Speculative Line Threshold (number of in-order double words before abandonment

//@MG: A study using test_bl/mems shows that FLSTA has zero cost. Without FLSTA, no
// alignment exceptions were generated by integer loads/stores regardless of L1D setting.
// FLSTA does not affect FPU alignment requirements.
#define     CCR0_INIT     (CCR0_CPRE | CCR0_DTB | CCR0_GDCBT | CCR0_ICSLC(0) | CCR0_ICSLT(2))
//@MG: L1_FULL_RECOVERY also requires TLBs mark L1D Write-Thru.
#define     CCR0_INIT_L1_FULL_RECOVERY  (CCR0_PRE | CCR0_INIT)


#define SPRN_CCR1        0x378      // Configuration Control Register 1 (Avenger Only)
#define   CCR1_ICDPEI(x)  _B8( 7,x) //   I-Cache Data  Parity Error Insertion
#define   CCR1_ICTPEI(x)  _B2( 9,x) //   I-Cache Tag   Parity Error Insertion
#define   CCR1_DCTPEI(x)  _B2(11,x) //   D-Cache Tag   Parity Error Insertion
#define   CCR1_DCDPEI     _BN(12)   //   D-Cache Data  Parity Error Insertion
#define   CCR1_DCUPEI     _BN(13)   //   D-Cache U-Bit Parity Error Insertion
#define   CCR1_DCMPEI     _BN(14)   //   D-Cache Modified-Bit Parity Error Insertion
#define   CCR1_FCOM       _BN(15)   //   Force Cache Operation Miss
#define   CCR1_MMUPEI(x)  _B4(19,x) //   Memory Management Unit Parity Error Insertion
#define   CCR1_FFF        _BN(20)   //   Force Full-line D-Cache Flush (even when 1/2 line is required)
//#define   CCR1_Rsvd_DCPC  _BN(23)   //   RESERVED/UNDOCUMENTED Disable Cache Parity Checking
#define   CCR1_TCS        _BN(24)   //   Timer Clock Select (Set to Zero!)
#define   CCR1_L2COBE     _BN(25)   //   L2 Cache OP Broadcast Enable (0=Disabled)
#define   CCR1_STATUSE    _BN(26)   //   Undocumented bit requried to drive cache status bits, must be set always
#define   CCR1_THUMPER    _BN(27)   //   Undocumented bit, supports Thumper, not recommended if FPU Attached!
#define  CCR1_AT_RESET    (0)            //  L2COBE cannot be enabled until after the TLB is set up.
#define  CCR1_INIT        (CCR1_L2COBE|CCR1_STATUSE)  //  After we install our TLBs, we switch to this.

#define SPRN_CSRR0     0x03A        // Critical Save/Restore Register 0: Return Addr
#define SPRN_CSRR0_PC  SPRN_CSRR0   //   alias for more descriptive name
#define SPRN_CSRR1     0x03B        // Critical Save/Restore Register 1: MSR
#define SPRN_CSRR1_MSR SPRN_CSRR1   //   alias for more descriptive name

#define SPRN_CTR       0x009        // Count Register

// Machine State Register (MSR) Bits (440_UM p.10-46)
//#define MSR_POW        _BN(13)      // Enable Power Management
#define MSR_WE         _BN(13)      // Wait State Enable
#define MSR_CE         _BN(14)      // Critical Interrupt Enable
#define MSR_EE         _BN(16)      // External Interrupt Enable
#define MSR_PR         _BN(17)      // Problem State (0=Sup, 1=Usr)
#define MSR_FP         _BN(18)      // Floating Point Available/Enable
#define MSR_ME         _BN(19)      // Machine Check Enable
#define MSR_FE0        _BN(20)      // Floating-Point Exception Mode 0
//#define MSR_SE         _BN(21)      // Single-Step Trace Enable
#define MSR_DWE        _BN(21)      // Debug Wait Enable
#define MSR_DE         _BN(22)      // Debug Exception Enable
#define MSR_FE1        _BN(23)      // Floating Exception mode 1
#define MSR_IS         _BN(26)      // Instruction Address Space
#define MSR_DS         _BN(27)      // Data Address Space

#define MSR_DISABLED (MSR_ME | MSR_FP)                   // Enable MachineCheck and the FPU while initializing
#define MSR_BSTRAP   (MSR_ME | MSR_FP)                   // Only MachineCheck and the FPU.
#define MSR_KERNEL   (MSR_ME | MSR_FP | MSR_CE | MSR_EE) // Normal Kernel Run-Mode

#define SPRN_MCSRR0      0x23A        // Machine Check Save/Restore Register 0: Return Addr
#define SPRN_MCSRR1      0x23B        // Machine Check Save/Restore Register 1: MSR
#define SPRN_MCSRR0_PC   SPRN_MCSRR0  // alias to more descriptive name
#define SPRN_MCSRR1_MSR  SPRN_MCSRR1  // alias to more descriptive name
#define SPRN_MCSR        0x23C        // Machine Check Status Register (Read/WriteClear)
#define  MCSR_MCS         _BN(0)      //   Machine Check Summary
#define  MCSR_IPLBE       _BN(1)      //   Instruction PLB Error
#define  MCSR_DRPLBE      _BN(2)      //   Data Read  PLB Error
#define  MCSR_DWPLBE      _BN(3)      //   Data Write PLB Error
#define  MCSR_TLBE        _BN(4)      //   TLB Error
#define  MCSR_ICPE        _BN(5)      //   I-Cache Parity Error
#define  MCSR_DCSPE       _BN(6)      //   D-Cache Search Parity Error
#define  MCSR_DCFPE       _BN(7)      //   D-Cache Flush  Parity Error
#define  MCSR_IMCE        _BN(8)      //   Imprecise Machine Check Exception

#define SPRN_DAC1      0x13C        // Data Address Compare 1
#define SPRN_DAC2      0x13D        // Data Address Compare 2
#define SPRN_DBCR0     0x134                    // Debug Control Register 0
#define   DBCR0_EDM     _BN( 0)                 //  External Debug Mode
#define   DBCR0_IDM     _BN( 1)                 //  Internal Debug Mode
#define   DBCR0_RST(x)  _B2(3,x)                //  Reset
#define     DBCR0_RST_NONE   DBCR0_RST(0)       //   None
#define     DBCR0_RST_CORE   DBCR0_RST(1)       //   Core
#define     DBCR0_RST_CHIP   DBCR0_RST(2)       //   Chip
#define     DBCR0_RST_SYS    DBCR0_RST(3)       //   System
#define   DBCR0_ICMP    _BN( 4)                 //  Instruction Completion Debug Event
#define   DBCR0_BRT     _BN( 5)                 //  Branch Taken Debug Event
#define   DBCR0_IRPT    _BN( 6)                 //  Interrupt Debug Event
#define   DBCR0_TRAP    _BN( 7)                 //  Trap Debug Event
#define   DBCR0_IAC1    _BN( 8)                 //  IAC 1 Debug Event
#define   DBCR0_IAC2    _BN( 9)                 //  IAC 2 Debug Event
#define   DBCR0_IAC3    _BN(10)                 //  IAC 3 Debug Event
#define   DBCR0_IAC4    _BN(11)                 //  IAC 4 Debug Event
#define   DBCR0_DAC1R   _BN(12)                 //  DAC 1 Read  Debug Event
#define   DBCR0_DAC1W   _BN(13)                 //  DAC 1 Write Debug Event
#define   DBCR0_DAC2R   _BN(14)                 //  DAC 2 Read  Debug Event
#define   DBCR0_DAC2W   _BN(15)                 //  DAC 2 Write Debug Event
#define   DBCR0_RET     _BN(16)                 //  Return Debug Event (rfi, rfci)
#define   DBCR0_FT      _BN(31)                 //  Freeze Timers on Debug Event
#define   DBCR0_INIT    0x00000000              //  Disable all debug events!
#define SPRN_DBCR1     0x135                    // Debug Control Register 1
#define   DBCR1_IAC1US(x)     _B2( 1,x)         //  User or Supervisor state
#define   DBCR1_IAC1US_BOTH   DBCR1_IAC1US(0)   //   Both
#define   DBCR1_IAC1US_SUP    DBCR1_IAC1US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR1_IAC1US_USR    DBCR1_IAC1US(3)   //   User Only: MSR[PR]=1
#define   DBCR1_IAC1ER(x)     _B2( 3,x)         //  IAC1 Effective or Real
#define   DBCR1_IAC1ER_EFF    DBCR1_IAC1ER(0)   //   Effective, MSR[IS] = Don't Care
#define   DBCR1_IAC1ER_VIS0   DBCR1_IAC1ER(2)   //   Virtual, MSR[IS] = 0
#define   DBCR1_IAC1ER_VIS1   DBCR1_IAC1ER(3)   //   Virtual, MSR[IS] = 1
#define   DBCR1_IAC2US(x)     _B2( 5,x)         //  IAC2 User or Supervisor
#define   DBCR1_IAC2US_BOTH   DBCR1_IAC2US(0)   //   Both
#define   DBCR1_IAC2US_SUP    DBCR1_IAC2US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR1_IAC2US_USR    DBCR1_IAC2US(3)   //   USer Only: MSR[PR]=1
#define   DBCR1_IAC2ER(x)     _B2( 7,x)         //  IAC2 Effective or Real
#define   DBCR1_IAC2ER_EFF    DBCR1_IAC2ER(0)   //   Effective, MSR[IS] = Don't Care
#define   DBCR1_IAC2ER_VIS0   DBCR1_IAC2ER(2)   //   Virtual, MSR[IS] = 0
#define   DBCR1_IAC2ER_VIS1   DBCR1_IAC2ER(3)   //   Virtual, MSR[IS] = 1
#define   DBCR1_IAC12M(x)     _B2( 9,x)         //  IAC 1/2 Mode
#define   DBCR1_IAC12M_EXCT   DBCR1_IAC12M(0)   //   Exact Match
#define   DBCR1_IAC12M_INCL   DBCR1_IAC12M(2)   //   Range Inclusive
#define   DBCR1_IAC12M_EXCL   DBCR1_IAC12M(3)   //   Range Exclusive
#define   DBCR1_IAC12AT       _BN(15)           //  IAC 1/2 Toggle Enable
#define   DBCR1_IAC3US(x)     _B2(17,x)         //  IAC3 User or Supervisor
#define   DBCR1_IAC3US_BOTH   DBCR1_IAC3US(0)   //   Both
#define   DBCR1_IAC3US_SUP    DBCR1_IAC3US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR1_IAC3US_USR    DBCR1_IAC3US(3)   //   USer Only: MSR[PR]=1
#define   DBCR1_IAC3ER(x)     _B2(19,x)         //  IAC3 Effective or Real
#define   DBCR1_IAC3ER_EFF    DBCR1_IAC3ER(0)   //   Effective, MSR[IS] = Don't Care
#define   DBCR1_IAC3ER_VIS0   DBCR1_IAC3ER(2)   //   Virtual, MSR[IS] = 0
#define   DBCR1_IAC3ER_VIS1   DBCR1_IAC3ER(3)   //   Virtual, MSR[IS] = 1
#define   DBCR1_IAC4US(x)     _B2(21,x)         //  IAC4 User or Supervisor
#define   DBCR1_IAC4US_BOTH   DBCR1_IAC4US(0)   //   Both
#define   DBCR1_IAC4US_SUP    DBCR1_IAC4US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR1_IAC4US_USR    DBCR1_IAC4US(3)   //   USer Only: MSR[PR]=1
#define   DBCR1_IAC4ER(x)     _B2(23,x)         //  IAC4 Effective or Real
#define   DBCR1_IAC4ER_EFF    DBCR1_IAC4ER(0)   //   Effective, MSR[IS] = Don't Care
#define   DBCR1_IAC4ER_VIS0   DBCR1_IAC4ER(2)   //   Virtual, MSR[IS] = 0
#define   DBCR1_IAC4ER_VIS1   DBCR1_IAC4ER(3)   //   Virtual, MSR[IS] = 1
#define   DBCR1_IAC34M(x)     _B2(25,x)         //  IAC 3/4 Mode
#define   DBCR1_IAC34M_EXCT   DBCR1_IAC34M(0)   //   Exact Match
#define   DBCR1_IAC34M_INCL   DBCR1_IAC34M(2)   //   Range Inclusive
#define   DBCR1_IAC34M_EXCL   DBCR1_IAC34M(3)   //   Range Exclusive
#define   DBCR1_IAC34AT       _BN(31)           //  IAC 3/4 Toggle Enable
#define   DBCR1_INIT          0x00000000        //  Initialization value.
#define SPRN_DBCR2     0x136                    // Debug Control Register 2
#define   DBCR2_DAC1US(x)     _B2( 1,x)         //  DAC1 User or Supervisor state
#define   DBCR2_DAC1US_BOTH   DBCR2_DAC1US(0)   //   Both
#define   DBCR2_DAC1US_SUP    DBCR2_DAC1US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR2_DAC1US_USR    DBCR2_DAC1US(3)   //   User Only: MSR[PR]=1
#define   DBCR2_DAC1ER(x)     _B2( 3,x)         //  DAC1 Effective or Real
#define   DBCR2_DAC1ER_EFF    DBCR2_DAC1ER(0)   //   Effective, MSR[DS] = Don't Care
#define   DBCR2_DAC1ER_VDS0   DBCR2_DAC1ER(2)   //   Virtual, MSR[DS] = 0
#define   DBCR2_DAC1ER_VDS1   DBCR2_DAC1ER(3)   //   Virtual, MSR[DS] = 1
#define   DBCR2_DAC2US(x)     _B2( 5,x)         //  DAC2 User or Supervisor state
#define   DBCR2_DAC2US_BOTH   DBCR2_DAC2US(0)   //   Both
#define   DBCR2_DAC2US_SUP    DBCR2_DAC2US(2)   //   Sup  Only: MSR[PR]=0
#define   DBCR2_DAC2US_USR    DBCR2_DAC2US(3)   //   User Only: MSR[PR]=1
#define   DBCR2_DAC2ER(x)     _B2( 7,x)         //  DAC2 Effective or Real
#define   DBCR2_DAC2ER_EFF    DBCR2_DAC2ER(0)   //   Effective, MSR[DS] = Don't Care
#define   DBCR2_DAC2ER_VDS0   DBCR2_DAC2ER(2)   //   Virtual, MSR[DS] = 0
#define   DBCR2_DAC2ER_VDS1   DBCR2_DAC2ER(3)   //   Virtual, MSR[DS] = 1
#define   DBCR2_DAC12M(x)     _B2( 9,x)         //  DAC 1/2 Mode
#define   DBCR2_DAC12M_EXCT   DBCR2_DAC12M(0)   //   Exact Match
#define   DBCR2_DAC12M_AMSK   DBCR2_DAC12M(1)   //   Address Bit Mask
#define   DBCR2_DAC12M_INCL   DBCR2_DAC12M(2)   //   Range Inclusive
#define   DBCR2_DAC12M_EXCL   DBCR2_DAC12M(3)   //   Range Exclusive
#define   DBCR2_DAC12A        _BN(10)           //  DAC 1/2 Asynchronous Enable
#define   DBCR2_DVC1M(x)      _B2(13,x)         //  Data Value Compare 1 Mode
#define   DBCR2_DVC1M_AND     DBCR2_DVC1M(1)    //   AND all bytes enabled by DVC2BE
#define   DBCR2_DVC1M_OR      DBCR2_DVC1M(2)    //   OR  all bytes enabled by DVC2BE
#define   DBCR2_DVC1M_AND_OR  DBCR2_DVC1M(3)    //   AND-OR byte pairs enabled by DVC2BE
#define   DBCR2_DVC2M(x)      _B2(15,x)         //  Data Value Compare 2 Mode
#define   DBCR2_DVC2M_AND     DBCR2_DVC2M(1)    //   AND all bytes enabled by DVC2BE
#define   DBCR2_DVC2M_OR      DBCR2_DVC2M(2)    //   OR  all bytes enabled by DVC2BE
#define   DBCR2_DVC2M_AND_OR  DBCR2_DVC2M(3)    //   AND-OR byte pairs enabled by DVC2BE
#define   DBCR2_1BE(x)        _B4(23,x)         //  DVC 1 Byte Enables 0:3
#define   DBCR2_2BE(x)        _B4(31,x)         //  DVC 2 Byte Enables 0:3
#define   DBCR2_INIT          0x00000000        //  Initialization value.
#define SPRN_DBDR      0x3F3                    // Debug Data Register
#define SPRN_DBSR      0x130                    // Debug Status Register
#define   DBSR_IDE      _BN( 0)                 //  Imprecise Debug Event
#define   DBSR_UDE      _BN( 1)                 //  Unconditional Debug Event
#define   DBSR_MRR(x)   _B2( 3,x)               //  Most Recent Reset
#define   DBSR_MRR_NONE DBSR_MRR(0)             //   No reset since last cleared
#define   DBSR_MRR_CORE DBSR_MRR(1)             //   Core
#define   DBSR_MRR_CHIP DBSR_MRR(2)             //   Chip
#define   DBSR_MRR_SYS  DBSR_MRR(3)             //   System
#define   DBSR_ICMP     _BN( 4)                 //  Instruction Completion Debug Event
#define   DBSR_BRT      _BN( 5)                 //  Branch Taken Debug Event
#define   DBSR_IRPT     _BN( 6)                 //  Interrupt Debug Event
#define   DBSR_TRAP     _BN( 7)                 //  Trap Debug Event
#define   DBSR_IAC1     _BN( 8)                 //  IAC 1 Debug Event
#define   DBSR_IAC2     _BN( 9)                 //  IAC 2 Debug Event
#define   DBSR_IAC3     _BN(10)                 //  IAC 3 Debug Event
#define   DBSR_IAC4     _BN(11)                 //  IAC 4 Debug Event
#define   DBSR_DAC1R    _BN(12)                 //  DAC 1 Read  Debug Event
#define   DBSR_DAC1W    _BN(13)                 //  DAC 1 Write Debug Event
#define   DBSR_DAC2R    _BN(14)                 //  DAC 2 Read  Debug Event
#define   DBSR_DAC2W    _BN(15)                 //  DAC 2 Write Debug Event
#define   DBSR_RET      _BN(16)                 //  Return Debug Event
#define   DBSR_IAC12ATS _BN(30)                 //  IAC 1/2 Auto-Toggle Status
#define   DBSR_IAC34ATS _BN(31)                 //  IAC 3/4 Auto-Toggle Status
#define   DBSR_INIT     0xFFFFFFFF              //  Clear all Pending Debug Events
#define SPRN_DCDBTRH   0x39D                    // Data Cache Debug Tag Register High
#define SPRN_DCDBTRL   0x39C                    // Data Cache Debug Tag Register Low
#define SPRN_DCRIPR    0x37B                    // DCR Immediate Prefix Register (ppc450 only)
#define  DCRIPR_UOA(x)  _B22(21,x)              //  Upper Order Address bits 0..21
#define  DCRIPR_INIT    (0)                     //  Initialization value
#define SPRN_DEAR      0x03D        // Data Exception Address Register
#define SPRN_DEC       0x016        // Decrementer
#define SPRN_DECAR     0x036        // Decrementer Auto-Reload (Sup R/O)
#define SPRN_DNV0      0x390        // Data Cache Normal Victim 0
#define  DNVx_VNDXA(x)     _B8( 7,x)
#define  DNVx_VNDXB(x)     _B8(15,x)
#define  DNVx_VNDXC(x)     _B8(23,x)
#define  DNVx_VNDXD(x)     _B8(31,x)
#define  DNV0_INIT     (DNVx_VNDXA(0) | DNVx_VNDXB(16) | DNVx_VNDXC(32) | DNVx_VNDXD(48))

#define SPRN_DNV1      0x391        // Data Cache Normal Victim 1
#define  DNV1_INIT     (DNVx_VNDXA(0) | DNVx_VNDXB(16) | DNVx_VNDXC(32) | DNVx_VNDXD(48))
#define SPRN_DNV2      0x392        // Data Cache Normal Victim 2
#define  DNV2_INIT     (DNVx_VNDXA(0) | DNVx_VNDXB(16) | DNVx_VNDXC(32) | DNVx_VNDXD(48))
#define SPRN_DNV3      0x393        // Data Cache Normal Victim 3
#define  DNV3_INIT     (DNVx_VNDXA(0) | DNVx_VNDXB(16) | DNVx_VNDXC(32) | DNVx_VNDXD(48))
#define  DNVx_INIT    DNV0_INIT    // DNV0..3 are all the same

#define SPRN_DTV0      0x394        // Data Transient Normal Victim 0
#define  DTVx_VNDXA(x)  _B8( 7,x)   //  Victim A: EA[25:26] = 0b00
#define  DTVx_VNDXB(x)  _B8(15,x)   //  Victim B: EA[25:26] = 0b01
#define  DTVx_VNDXC(x)  _B8(23,x)   //  Victim C: EA[25:26] = 0b10
#define  DTVx_VNDXD(x)  _B8(31,x)   //  Victim D: EA[25:26] = 0b11
#define  DTV0_INIT     (DTVx_VNDXA(0) | DTVx_VNDXB(16) | DTVx_VNDXC(32) | DTVx_VNDXD(48))
#define SPRN_DTV1      0x395        // Data Transient Normal Victim 1
#define  DTV1_INIT     (DTVx_VNDXA(0) | DTVx_VNDXB(16) | DTVx_VNDXC(32) | DTVx_VNDXD(48))
#define SPRN_DTV2      0x396        // Data Transient Normal Victim 2
#define  DTV2_INIT     (DTVx_VNDXA(0) | DTVx_VNDXB(16) | DTVx_VNDXC(32) | DTVx_VNDXD(48))
#define SPRN_DTV3      0x397        // Data Transient Normal Victim 3
#define  DTV3_INIT     (DTVx_VNDXA(0) | DTVx_VNDXB(16) | DTVx_VNDXC(32) | DTVx_VNDXD(48))
#define  DTVx_INIT     DTV0_INIT    // DTV0..3 are all the same

#define SPRN_DCV1      0x13E        // Data Value Compare Registers 1
#define SPRN_DCV2      0x13F        // Data Value Compare Registers 2
#define SPRN_DVLIM     0x398        // Data Cache Victim Limit
#define  DVLIM_TFLOOR(x)   _B8( 9,x)   //  Transient Floor
#define  DVLIM_TCEILING(x) _B8(20,x)   //  Transient Ceiling
#define  DVLIM_NFLOOR(x)   _B8(31,x)   //  Normal Floor
                       // INIT: Normal and Transient share entire cache, nothing locked
                       // To lock lines, raise TFLOOR and NFLOOR,
                       //  but always keep TFLOOR <= NFLOOR
                       //  ie, Locked lines:    0..TFLOOR-1
                       //      Transient Lines: TFLOOR..TCEILING-1
                       //      Normal Lines:    TFLOOR..63
#define  DVLIM_INIT    (DVLIM_TFLOOR(0) | DVLIM_TCEILING(63) | DVLIM_NFLOOR(0))
#define SPRN_ESR       0x03E        // Exception Syndrome Register
#define   ESR_MCI       _BN( 0)     //  Machine Check I-Fetch Exception
#define   ESR_PIL       _BN( 4)     //  Program Interrupt Illegal Instruction Exception
#define   ESR_PPR       _BN( 5)     //  Program Interrupt Privileged Instruction Exception
#define   ESR_PTR       _BN( 6)     //  Program Interrupt Trap Exception
#define   ESR_FP        _BN( 7)     //  Floating Point Operation
#define   ESR_ST        _BN( 8)     //  Store Operation
#define   ESR_DLK(x)    _B2(11,x)   //  Data Store Interrupt: Locking Exception
#define    ESR_DLK_NONE ESR_DLK(0)  //   Did not occur
#define    ESR_DLK_DCBF ESR_DLK(1)  //   Caused by dcbf
#define    ESR_DLK_ICBI ESR_DLK(2)  //   Caused by icbi
#define   ESR_AP        _BN(12)     //  Aux Processor Operation
#define   ESR_PUO       _BN(13)     //  Program Interrupt - Unimplemented Operation Exception
#define   ESR_BO        _BN(14)     //  Byte Ordering Exception
#define   ESR_PIE       _BN(15)     //  Program Interrupt - Imprecise Exception
#define   ESR_PCRE      _BN(27)     //  Program Interrupt - FP Condition Register Update
#define   ESR_PCMP      _BN(28)     //  Program Interrupt - FP Compare Instruction
#define   ESR_PCRF(x)   _B3(31,x)   //  Program Interrupt - Condition Register Field
#define   ESR_INIT      0x00000000  //  Clear all ESR interrupts
#define SPRN_IAC1      0x138        // Instruction Address Compare Register 1
#define SPRN_IAC2      0x139        // Instruction Address Compare Register 2
#define SPRN_IAC3      0x13A        // Instruction Address Compare Register 3
#define SPRN_IAC4      0x13B        // Instruction Address Compare Register 4
#define SPRN_ICDBDR    0x3D3        // I-Cache Debug Data Register
#define SPRN_ICDBTRH   0x39F        // I-Cache Debug Tag Register High
#define SPRN_ICDBTRL   0x39E        // I-Cache Debug Tag Register Low

#define SPRN_INV0      0x370        // I-Cache Normal Victim 0
#define  INVx_VNDXA(x)  _B8( 7,x)   //  Victim A: EA[25:26] = 0b00
#define  INVx_VNDXB(x)  _B8(15,x)   //  Victim B: EA[25:26] = 0b01
#define  INVx_VNDXC(x)  _B8(23,x)   //  Victim C: EA[25:26] = 0b10
#define  INVx_VNDXD(x)  _B8(31,x)   //  Victim D: EA[25:26] = 0b11
#define  INV0_INIT     (INVx_VNDXA(0) | INVx_VNDXB(16) | INVx_VNDXC(32) | INVx_VNDXD(48))
#define SPRN_INV1      0x371        // I-Cache Normal Victim 1
#define  INV1_INIT     (INVx_VNDXA(0) | INVx_VNDXB(16) | INVx_VNDXC(32) | INVx_VNDXD(48))
#define SPRN_INV2      0x372        // I-Cache Normal Victim 2
#define  INV2_INIT     (INVx_VNDXA(0) | INVx_VNDXB(16) | INVx_VNDXC(32) | INVx_VNDXD(48))
#define SPRN_INV3      0x373        // I-Cache Normal Victim 3
#define  INV3_INIT     (INVx_VNDXA(0) | INVx_VNDXB(16) | INVx_VNDXC(32) | INVx_VNDXD(48))
#define  INVx_INIT     INV0_INIT    // INV0..3 are all the same

#define SPRN_ITV0      0x374        // I-Cache Transient Victim 0
#define  ITVx_VNDXA(x)  _B8( 7,x)   //  Victim A: EA[25:26] = 0b00
#define  ITVx_VNDXB(x)  _B8(15,x)   //  Victim B: EA[25:26] = 0b01
#define  ITVx_VNDXC(x)  _B8(23,x)   //  Victim C: EA[25:26] = 0b10
#define  ITVx_VNDXD(x)  _B8(31,x)   //  Victim D: EA[25:26] = 0b11
#define  ITV0_INIT     (ITVx_VNDXA(0) | ITVx_VNDXB(16) | ITVx_VNDXC(32) | ITVx_VNDXD(48))
#define SPRN_ITV1      0x375        // I-Cache Transient Victim 1
#define  ITV1_INIT     (ITVx_VNDXA(0) | ITVx_VNDXB(16) | ITVx_VNDXC(32) | ITVx_VNDXD(48))
#define SPRN_ITV2      0x376        // I-Cache Transient Victim 2
#define  ITV2_INIT     (ITVx_VNDXA(0) | ITVx_VNDXB(16) | ITVx_VNDXC(32) | ITVx_VNDXD(48))
#define SPRN_ITV3      0x377        // I-Cache Transient Victim 3
#define  ITV3_INIT     (ITVx_VNDXA(0) | ITVx_VNDXB(16) | ITVx_VNDXC(32) | ITVx_VNDXD(48))
#define  ITVx_INIT     ITV0_INIT    // ITV0..3 are all the same

#define SPRN_IVLIM     0x399        // I-Cache Victim Limit
#define  IVLIM_TFLOOR(x)   _B8( 9,x)   //  Transient Floor
#define  IVLIM_TCEILING(x) _B8(20,x)   //  Transient Ceiling
#define  IVLIM_NFLOOR(x)   _B8(31,x)   //  Normal Floor
                       // INIT: Normal and Transient share entire cache, nothing locked
                       //  To lock lines, raise TFLOOR and NFLOOR,
                       //   but always keep TFLOOR <= NFLOOR
                       //   ie, Locked lines:    0..TFLOOR-1
                       //       Transient Lines: TFLOOR..TCEILING-1
                       //       Normal Lines:    TFLOOR..63
#define  IVLIM_INIT    (IVLIM_TFLOOR(0) | IVLIM_TCEILING(63) | IVLIM_NFLOOR(0))

#define SPRN_IVOR0     0x190        // Interrupt Vector Offset Register  0
#define SPRN_IVOR1     0x191        // Interrupt Vector Offset Register  1
#define SPRN_IVOR2     0x192        // Interrupt Vector Offset Register  2
#define SPRN_IVOR3     0x193        // Interrupt Vector Offset Register  3
#define SPRN_IVOR4     0x194        // Interrupt Vector Offset Register  4
#define SPRN_IVOR5     0x195        // Interrupt Vector Offset Register  5
#define SPRN_IVOR6     0x196        // Interrupt Vector Offset Register  6
#define SPRN_IVOR7     0x197        // Interrupt Vector Offset Register  7
#define SPRN_IVOR8     0x198        // Interrupt Vector Offset Register  8
#define SPRN_IVOR9     0x199        // Interrupt Vector Offset Register  9
#define SPRN_IVOR10    0x19A        // Interrupt Vector Offset Register 10
#define SPRN_IVOR11    0x19B        // Interrupt Vector Offset Register 11
#define SPRN_IVOR12    0x19C        // Interrupt Vector Offset Register 12
#define SPRN_IVOR13    0x19D        // Interrupt Vector Offset Register 13
#define SPRN_IVOR14    0x19E        // Interrupt Vector Offset Register 14
#define SPRN_IVOR15    0x19F        // Interrupt Vector Offset Register 15
#define SPRN_IVPR      0x03F        // Interrupt Vector Prefix Register
#define SPRN_LR        0x008        // Link Register

#define SPRN_MMUCR     0x3B2        // Memory Management Control Register
#define   MMUCR_L2SWOA    _BN( 6)     //  L2 Store Without Allocate
#define   MMUCR_SWOA      _BN( 7)     //  Store WithOut Allocate (ignored if MMUCR_U2SWOAE)
#define   MMUCR_U1TE      _BN( 9)     //  U1 Transient Enable
#define   MMUCR_U2SWOAE   _BN(10)     //  U2 Store WithOut Allocate Enable
#define   MMUCR_U3L2SWOAE _BN(11)     //  U3 L2 Store WithOut Allocate Enable
#define   MMUCR_DULXE     _BN(12)     //  Data Cache Unlock Exception Enable
#define   MMUCR_IULXE     _BN(13)     //  Instruction Cache Unlock Exception Enable
#define   MMUCR_STS       _BN(15)     //  Search Translation Space
#define   MMUCR_STID(x)   _B8(31,x)   //  Search Translation ID: MMUCR[24:31]
#define   MMUCR_INIT    (MMUCR_U1TE | MMUCR_U2SWOAE)

#define SPRN_PID       0x030        // Process ID
#define  PID_PID(x)     _B8(31)     //  8 bit Process ID Field
#define  PID_INIT       0x00000000  // Init to PID=0
#define SPRN_PIR       0x11E        // Processor Identification Register
#define  PIR_PIN(x)     _B8(31,x)   //  8 bit Processor ID Number (Sup R/O) (0 to 3)

#define SPRN_PVR          0x11F         // Processor Version Register (Sup R/O)
#define  _PVR_PPC450_DD10  (0x52131800) //  PVR for PPC450 Core PPC450CPUA6V1A (DD1.0)
#define  _PVR_PPC450_DD20  (0x52131880) //  PVR for PPC450 Core PPC450CPUA6V3BG  (DD2.0 and DD2.1)
#define  _PVR_PPC450       (_PVR_PPC450_DD10) // current

#define SPRN_RSTCFG    0x39B        // Reset Configuration (Sup R/O)
#define  RSTCFG_U0      _BN(16)     //  U0 Storage Attribute Enable
#define  RSTCFG_U1      _BN(17)     //  U1 Storage Attribute Enable
#define  RSTCFG_U2      _BN(18)     //  U2 Storage Attribute Enable
#define  RSTCFG_U3      _BN(19)     //  U3 Storage Attribute Enable
#define  RSTCFG_E       _BN(24)     //  Endian Attribute (0=Big, 1=Little)
#define  RSTCFG_EPRN(x) _B8(31)     //  Extended Real Page Number
#define SPRN_SPRG0RO    0x110       // SPR General 0 (Sup Read Only)
#define SPRN_SPRG0WO    0x110       // SPR General 0 (Sup Write Only)
#define SPRN_SPRG1RO    0x111       // SPR General 1 (Sup Read Only)
#define SPRN_SPRG1WO    0x111       // SPR General 1 (Sup Write Only)
#define SPRN_SPRG2RO    0x112       // SPR General 2 (Sup Read Only)
#define SPRN_SPRG2WO    0x112       // SPR General 2 (Sup Write Only)
#define SPRN_SPRG3RO    0x113       // SPR General 3 (Sup Read Only)
#define SPRN_SPRG3WO    0x113       // SPR General 3 (Sup Write Only)
#define SPRN_SPRG4WO    0x114       // SPR General 4 (Sup W/O)
#define SPRN_SPRG5WO    0x115       // SPR General 5 (Sup W/O)
#define SPRN_SPRG6WO    0x116       // SPR General 6 (Sup W/O)
#define SPRN_SPRG7WO    0x117       // SPR General 7 (Sup W/O)
#define SPRN_SRR0       0x01A       // Save/Restore Register 0: Return Addr for Non-Critical
#define SPRN_SRR1       0x01B       // Save/Restore Register 1: MSR for Non-Critical
#define SPRN_SRR0_PC    SPRN_SRR0   // alias for more descriptive name
#define SPRN_SRR1_MSR   SPRN_SRR1   // alias for more descriptive name
#define SPRN_TBWL       0x11C       // Time Base Lower Register (sup, W/O)
#define SPRN_TBWU       0x11D       // Time Base Upper Register (sup, W/O)
#define SPRN_TCR        0x154       // Timer Control Register
#define   TCR_WP(x)      _B2( 1,x)  //  WDT Period
#define   TCR_WP_2_21    TCR_WP(0)  //   2^21 clocks
#define   TCR_WP_2_25    TCR_WP(1)  //   2^25 clocks
#define   TCR_WP_2_29    TCR_WP(2)  //   2^29 clocks
#define   TCR_WP_2_33    TCR_WP(3)  //   2^33 clocks
#define   TCR_WRC(x)     _B2( 3,x)  //  WDT Reset Control
#define   TCR_WRC_NONE   TCR_WRC(0) //   No reset will occur
#define   TCR_WRC_CORE   TCR_WRC(1) //   Core reset will occur
#define   TCR_WRC_CHIP   TCR_WRC(2) //   Chip reset will occur
#define   TCR_WRC_SYS    TCR_WRC(3) //   System reset will occur
#define   TCR_WIE         _BN( 4)    // WDT Interrupt Enable
#define   TCR_DIE         _BN( 5)    // DECrementer Interrupt Enable
#define   TCR_FP(x)       _B2( 7,x)  // FIT Period
#define    TCR_FP_2_13     TCR_FP(0)  //   2^13 clocks
#define    TCR_FP_2_17     TCR_FP(1)  //   2^17 clocks
#define    TCR_FP_2_21     TCR_FP(2)  //   2^21 clocks
#define    TCR_FP_2_25     TCR_FP(3)  //   2^25 clocks
#define   TCR_FIE        _BN( 8)    // FIT Interrupt Enable
#define   TCR_ARE        _BN( 9)    // Auto Reload Enable
#define   TCR_INIT      0x00000000  // Disable all Timer Interrupts

#define SPRN_TSR       0x150        // Timer Status Register (Read/Clear)
#define   TSR_ENW       _BN( 0)     //  Enable Next Watchdog
#define   TSR_WIS       _BN( 1)     //  WDT Interrupt Status
#define   TSR_WRS(x)    _B2( 3,x)   //  WDT Reset Status
#define    TSR_WRS_NONE  TSR_WRS(0)  //   No WDT reset occurred
#define    TSR_WRS_CORE  TSR_WRS(1)  //   WDT forced core reset
#define    TSR_WRS_CHIP  TSR_WRS(2)  //   WDT forced chip reset
#define    TSR_WRS_SYS   TSR_WRS(3)  //   WDT forced system reset
#define   TSR_DIS       _BN( 4)     //  DEC Interrupt Status
#define   TSR_FIS       _BN( 5)     //  FIT Interrupt Status
#define   TSR_INIT    0xFFFFFFFF    //  Clear all Pending Interrupt/Status Bits
#define SPRN_XER     0x001          // Fixed-Point Exception Register
#define   XER_SO      _BN( 0)       //  Summary Overflow
#define   XER_OV      _BN( 1)       //  Overflow
#define   XER_CA      _BN( 2)       //  Carry
#define   XER_TBC(x) ((x)&0x7f)     //  Transfer Byte Count (for lswx and stswx)

// Describe the FPSCR
#define FPSCR_FX        _BN( 0)            //   FP Exception Summary
#define FPSCR_FEX       _BN( 1)            //   FP Enabled Exception Summary
#define FPSCR_VX        _BN( 2)            //   FP Invalid Operation Exception Summary
#define FPSCR_OX        _BN( 3)            //   FP Invalid Overflow Exception (Stickey)
#define FPSCR_UX        _BN( 4)            //   FP Invalid Underflow Exception (Stickey)
#define FPSCR_ZX        _BN( 5)            //   FP Zero Divide Exception (Stickey)
#define FPSCR_XX        _BN( 6)            //   FP Inexact Exception (Stickey)
#define FPSCR_VXSNAN    _BN( 7)            //   FP Invalid Operation Exception for SNaN (Stickey)
#define FPSCR_VXISI     _BN( 8)            //   FP Invalid Operation Exception for Inf-Inf (Stickey)
#define FPSCR_VXIDI     _BN( 9)            //   FP Invalid Operation Exception for Inf/Inf (Stickey)
#define FPSCR_VXZDZ     _BN(10)            //   FP Invalid Operation Exception for 0/0 (Stickey)
#define FPSCR_VXIMZ     _BN(11)            //   FP Invalid Operation Exception for Inf*0 (Stickey)
#define FPSCR_VXVC      _BN(12)            //   FP Invalid Operation Exception for Invalid Compare (Stickey)
#define FPSCR_FR        _BN(13)            //   FP Fraction Rounded
#define FPSCR_FI        _BN(14)            //   FP Fraction Inexact
#define FPSCR_FPRF(x)   _B5(19,x)          //   FP Result Flags (see 6xx_pem.pdf Table 2-5)
#define   FPSCR_FPRF_QNaN FPSCR_FPRF(0x11) //     Quiet NaN
#define   FPSCR_FPRF_MINF FPSCR_FPRF(0x09) //     Minus Inf
#define   FPSCR_FPRF_MNOR FPSCR_FPRF(0x08) //     Minus Normalized Number
#define   FPSCR_FPRF_MDEN FPSCR_FPRF(0x18) //     Minus Denormalized Number
#define   FPSCR_FPRF_MZ   FPSCR_FPRF(0x12) //     Minus Zero
#define   FPSCR_FPRF_PZ   FPSCR_FPRF(0x02) //     Plus  Zero
#define   FPSCR_FPRF_PDEN FPSCR_FPRF(0x14) //     Plus  Denormalized number
#define   FPSCR_FPRF_PNOR FPSCR_FPRF(0x04) //     Plus  Normalized number
#define   FPSCR_FPRF_PINF FPSCR_FPRF(0x03) //     Plus  Inf
#define FPSCR_Rsvd      _BN(20)            //   Reserved
#define FPSCR_VXSOFT    _BN(21)            //   FP Invalid Operation Exception for Software Request (Stickey)
#define FPSCR_VXSQRT    _BN(22)            //   FP Invalid Operation Exception for Invalid Square Root (Stickey)
#define FPSCR_VXCVI     _BN(23)            //   FP Invalid Operation Exception for Invalid Integer Convert (Stickey)
#define FPSCR_VE        _BN(24)            //   FP Invalid Operation Exception Enable
#define FPSCR_OE        _BN(25)            //   FP Overflow Exception Enable
#define FPSCR_UE        _BN(26)            //   FP Underflow Exception Enable
#define FPSCR_ZE        _BN(27)            //   FP Zero-Divide Exception Enable
#define FPSCR_XE        _BN(28)            //   FP Inexact Exception Enable
#define FPSCR_NI        _BN(29)            //   FP Non-IEEE Mode
#define FPSCR_RN(x)     _B2(30,x)          //   FP Rounding Control
#define   FPSCR_RN_NEAR   FPSCR_RN(0)      //     Round Nearest
#define   FPSCR_RN_ZERO   FPSCR_RN(1)      //     Round Toward Zero
#define   FPSCR_RN_PINF   FPSCR_RN(2)      //     Round Toward +Infinity
#define   FPSCR_RN_MINF   FPSCR_RN(3)      //     Round Toward -Infinity
#define FPSCR_INIT      (0)                // if Debug: (FPSCR_VE | FPSCR_OE | FPSCR_UE | FPSCR_ZE | FPSCR_XE)

// User-Mode SPRs. (Most are Read-Only.)
#define SPRN_SPRG4RO    0x104       // SPR General 4 (user & sup R/0)
#define SPRN_SPRG5RO    0x105       // SPR General 5 (user & sup R/0)
#define SPRN_SPRG6RO    0x106       // SPR General 6 (user & sup R/0)
#define SPRN_SPRG7RO    0x107       // SPR General 7 (user & sup R/0)

#define SPRN_TBRL       0x10C       // Time Base Read Lower Register (user & sup R/O)
#define SPRN_TBRU       0x10D       // Time Base Read Upper Register (user & sup R/O)

#define SPRN_USPRG0     0x100       // User SPR General 0 (user, R/W)

#if !defined(__ASSEMBLY__) && !defined(__BGP_HOST_COMPILED__) && !defined(__MAMBO__)

/*!\brief SRR0 is an SPR that is used to save machine state on non-critical interrupts
 *
 * SRR0 is an SPR that is used to save machine state on non-critical interrupts, and to 
 * restore machine state when an rfi is executed. When a non-critical interrupt occurs,
 * SRR0 is set to an address associated with the process which was executing at the time.
 * When rfi is executed, instruction execution returns to the address in SRR0.  
*/
typedef struct {
   unsigned int spr_srr0;          
} SPR_srr0_t;

/*!\brief CSRR0 is an SPR that is used to save machine state on critical interrupts.
 *
 * CSRR0 is an SPR that is used to save machine state on critical interrupts, and to restore machine state when
 * an rfci is executed. When a critical interrupt occurs, CSRR0 is set to an address associated with the process
 * which was executing at the time. When rfci is executed, instruction execution returns to the address in
 * CSRR0.
*/
typedef struct {
   unsigned int spr_csrr0;          
} SPR_csrr0_t;

/*!\brief MCSRR0 is an SPR that is used to save machine state on Machine Check interrupts.
 *
 * MCSRR0 is an SPR that is used to save machine state on Machine Check interrupts, and to restore machine
 * state when an rfmci is executed. When a machine check interrupt occurs, MCSRR0 is set to an address
 * associated with the process which was executing at the time. When rfmci is executed, instruction execution
 * returns to the address in MCSRR0.
 */
typedef struct {
   unsigned int spr_mcssr0;          
} SPR_mcsrr0_t;

/*!\brief MSR: Controls important chip functions such as enabling/disabling of interrupts
 *
 * MSR bit definitions:
 * <pre>
 *    Bits     Definition
 *    0:12           reserved
 *    13       WE    Wait State Enable
 *    14       CE    Critical interrupt enable
 *    15             reserved
 *    16       EE    External interrupt enable
 *    17       PR    Problem state
 *    18       FP    Floating point available
 *    19       ME    Machine check enable
 *    20       FE0   Floating point exception mode 0
 *    21       DWE   Debug wait enable
 *    22       DE    Debug interrupt enable
 *    23       FE1   Floating point exception mode 1
 *    24:25          reserved
 *    26       IS    Instruction address space
 *    27       DS    Data Address Space
 *    28:31          reserved
 </pre>
*/
typedef struct {
   unsigned int spr_msr;          
} SPR_msr_t;

/*!\brief SRR1 is an SPR that is used to save machine state on non-critical interrupts.
 *
* SRR1 is an SPR that is used to save machine state on non-critical interrupts, and to restore machine state
* when an rfi is executed. When a non-critical interrupt is taken, the contents of the MSR (prior to the MSR
* being cleared by the interrupt) are placed into SRR1. When rfi is executed, the MSR is restored with the
* contents of SRR1.
*/
typedef struct {
   unsigned int spr_srr1;          
} SPR_srr1_t;

/*!\brief CSRR1 CSRR1 is an SPR that is used to save machine state on critical interrupts.
 *
 * CSRR1 is an SPR that is used to save machine state on critical interrupts, and to restore machine state when
 * an rfci is executed. When a critical interrupt is taken, the contents of the MSR (prior to the MSR being cleared
 * by the interrupt) are placed into CSRR1. When rfci is executed, the MSR is restored with the contents of
 * CSRR1.
 */
typedef struct {
   unsigned int spr_csrr1;          
} SPR_csrr1_t;

/*!\brief MCSRR1 is an SPR that is used to save machine state on Machine Check interrupts.
 *
 * MCSRR1 is an SPR that is used to save machine state on Machine Check interrupts, and to restore machine
 * state when an rfmci is executed. When a machine check interrupt is taken, the contents of the MSR (prior to
 * the MSR being cleared by the interrupt) are placed into MCSRR1. When rfmci is executed, the MSR is
 * restored with the contents of MCSRR1.
 */
typedef struct {
   unsigned int spr_mcsrr1;          
} SPR_mcsrr1_t;

/*!\brief DEAR contains the address that was referenced by a load, store, or cache management instruction that
 * caused an Alignment, Data TLB Miss, or Data Storage exception.
 */
typedef struct {
   unsigned int spr_dear;          
} SPR_dear_t;

/*!\brief MCSR: The Machine Check Status Register contains status to allow the Machine Check interrupt handler software to determine the cause of a
 * machine check exception.
 *
 * The MCSR contains status to allow the Machine Check interrupt handler software to determine the cause of a
 * machine check exception. Any Machine Check exception that is handled as an asynchronous interrupt sets
 * MCSR[MCS] and other appropriate bits of the MCSR. If MSR[ME] and MCSR[MCS] are both set, the
 * machine will take a Machine Check interrupt.
 * <pre>
 * Bit   Name  Description
 * 0     MCS   Machine check summary
 * 1     IB    Instruction PLB Error
 * 2     DRB   Data Read PLB Error
 * 3     DWB   Data Write PLB Error
 * 4     TLBP  Translation Lookaside Buffer Parity Error
 * 5     ICP   Instruction Cache Parity Error
 * 6     DCSP  Data Cache Search Parity Error
 * 7     DCFP  Data Cache Flush Parity Error
 * 8     IMPE  Imprecise Machine Check Exception
 * 9:31        reserved
 * </pre>
 */
typedef struct {
   unsigned int spr_mcsr;          
} SPR_mcsr_t;


/*!\brief MMUCR: Memory Management Unit Control Register
 *
 * The MMUCR is written from a GPR using mtspr, and can be read into a GPR using mfspr. In addition, the
 * MMUCR[STID] is updated with the TID field of the selected TLB entry when a tlbre instruction is executed.
 * Conversely, the TID field of the selected TLB entry is updated with the value of the MMUCR[STID] field when
 * a tlbwe instruction is executed.
 * <pre>
 * Bits     Name        Description
 * 6        L2SWOA      L2 Store Without Allocate
 * 7        SWOA        Store Without Allocate
 * 8                    reserved
 * 9        U1TE        U1 Transient Enable
 * 10       U2SWOAE     U2 Store without Allocate Enable
 * 11       U3L2SWOAE   U3 L2 Store without Allocate Enable
 * 12       DULXE       Data Cache Unlock Exception Enable
 * 13       IULXE       Instruction Cache Unlock Exception Enable
 * 14                   reserved
 * 15       STS         Search Translation Space
 * 16:23                reserved
 * 24:31    STID        Search Translation ID
 * </pre>
*/
typedef struct {
   unsigned int spr_mmucr;          
} SPR_mmucr_t;

/*!\brief SPRG0-SPRG7: Special Purpose Registers 0 through 7. Provided for general purpose system-dependent software use.
*/
typedef struct {
   unsigned int spr_sprg0_sprg7;          
} SPR_sprg0_sprg7_t;

/*!\brief TSR: The Timer Status Register is a privileged SPR that records the status of DEC, FIT, and Watchdog Timer events.
 *
 * The TSR is a privileged SPR that records the status of DEC, FIT, and Watchdog Timer events. The fields of
 * the TSR are generally set to 1 only by hardware and cleared to 0 only by software. Hardware cannot clear
 * any fields in the TSR, nor can software set any fields. Software can read the TSR into a GPR using mfspr.
 * Clearing the TSR is performed using mtspr by placing a 1 in the GPR source register in all bit positions which
 * are to be cleared in the TSR, and a 0 in all other bit positions. The data written from the GPR to the TSR is not
 * direct data, but a mask. A 1 clears the bit and a 0 leaves the corresponding TSR bit unchanged.
 * <pre>
 * Bits  Name  Description
 * 0     ENW   Enable Next Watchdog Timer Exception
 * 1     WIS   Watchdog Timer Interrupt Status
 * 2:3   WRS   Watchdog Timer Reset Status
 * 4     DIS   Decrementer Interrupt Status
 * 5     FIS   Fixed Interval Timer (FIT) Interrupt Status
 * 6:31        reserved
 *</pre>
*/
typedef struct {
   unsigned int spr_tsr;          
} SPR_tsr_t;

/*!\brief DEC: The Decrementer is a 32-bit privileged SPR that decrements at the same rate that the time base increments.
 *
 * The DEC is a 32-bit privileged SPR that decrements at the same rate that the time base increments. The
 * DEC is read and written using mfspr and mtspr, respectively. When a non-zero value is written to the DEC,
 * it begins to decrement with the next time base clock. A Decrementer exception is signalled when a decrement
 * occurs on a DEC count of 1.
 *
*/
typedef struct {
   unsigned int spr_dec;          
} SPR_dec_t;

/*!\brief TCR: The Timer Control Register is a privileged SPR that controls DEC, FIT, and Watchdog Timer operation.
 *
 * The Watchdog Timer Reset Control (WRC) field of the TCR is cleared to 0 by processor reset.
 * Each bit of this 2-bit field is set only by software and is cleared only by hardware. For each
 * bit of the field, once software has written it to 1, that bit remains 1 until processor reset occurs. This is to
 * prevent errant code from disabling the Watchdog Timer reset function.
 * <pre>
 * Bits     Name  Description
 * 0:1      WP    Watchdog Timer Period
 * 2:3      WRC   Watchdog timer reset control
 * 4        WIE   Watchdog Timer Interrupt Enable
 * 5        DIE   Decrementer Interrupt Enable
 * 6:7      FP    Fixed Interval Timer (FIT) Period
 * 8        FIE   FIT Interrupt Enable
 * 9        ARE   Auto-Reload Enable
 * 10:31          reserved
 * </pre>
 */
typedef struct {
   unsigned int spr_tcr;          
} SPR_tcr_t;

/*!\brief ICDBDR: Instruction Cache Debug Data Register
 *
 * The ICDBDR register will contain the Instruction machine code from the instruction cache
 * after the execution if an icread instruction.
*/
typedef struct {
   unsigned int spr_icdbdr;          
} SPR_icdbdr_t;

/*!\brief ICDBTRH: Instruction Cache Debug Tag Register High
 *
 * <pre>
 * Bits     Name     Description
 * 0:23              Tag Effective Address
 * 24       V        Cache Line Valid
 * 25:26    TPAR     Tag Parity
 * 27       DAPAR    Instruction Data parity
 * </pre>   
*/
typedef struct {
   unsigned int spr_icdbtrh;          
} SPR_icdbtrh_t;

/*!\brief ICDBTRL: Instruction Cache Debug Tag Register Low
 *
 * <pre>
 * Bits     Name     Description
 * 0:21              reserved
 * 22       TS       Translation Space
 * 23       TD       Translation ID (TID) Disable
 * 24:31    TID      Translation ID
*/
typedef struct {
   unsigned int spr_icdbtrl;          
} SPR_icdbtrl_t;

/*!\brief DBSR: The Debug Status Register contains status on debug events as well as information on the type of the most recent reset.
 *
 * The DBSR contains status on debug events as well as information on the type of the most recent reset. The
 * status bits are set by the occurrence of debug events, while the reset type information is updated upon the
 * occurrence of any of the three reset types.
 * <pre>
 * Bits  Name     Description
 * 0     IDE      Imprecise Debug Event
 * 1     UDE      Unconditional Debug Event
 * 2:3   MRR      Most Recent Reset
 * 4     ICMP     Instruction Completion Debug Event
 * 5     BRT      Branch Taken Debug Event
 * 6     IRPT     Interrupt Debug event
 * 7     TRAP     Trap Debug Event
 * 8     IAC1     IAC 1 Debug Event
 * 9     IAC2     IAC 2 Debug Event
 * 10    IAC3     IAC 3 Debug Event
 * 11    IAC4     IAC 4 Debug Event
 * 12    DAC1R    DAC 1 Read Debug Event
 * 13    DAC1W    DAC 1 Write Debug Event
 * 14    DAC2R    DAC 2 Read Debug Event
 * 15    DAC2W    DAC 2 Write Debug Event
 * 16    RET      Return Debug Event
 * 17:29          reserved
 * 30    IAC12ATS IAC 1/2 Auto-Toggle Status
 * 31    IAC34ATS IAC 3/4 Auto-Toggle Status
 *</pre>
*/
typedef struct {
   unsigned int spr_dbsr;          
} SPR_dbsr_t;

/*!\brief DAC1: One of two Data Address Compare registers that specifieds the address upon which DAC (and/or DVC) debug events should occur.
*/
typedef struct {
   unsigned int spr_dac1;          
} SPR_dac1_t;

/*!\brief DAC2: One of two Data Address Compare registers that specifieds the address upon which DAC (and/or DVC) debug events should occur.
*/
typedef struct {
   unsigned int spr_dac2;          
} SPR_dac2_t;

/*!\brief IAC1: One of four IAC registers used to specify the addresses upon which IAC debug events should occur.
 *
*/
typedef struct {
   unsigned int spr_iac1;          
} SPR_iacIAC1t;

/*!\brief IAC2: One of four IAC registers used to specify the addresses upon which IAC debug events should occur.
 *
*/
typedef struct {
   unsigned int spr_iac2;          
} SPR_iac2_t;

/*!\brief IAC3: One of four IAC registers used to specify the addresses upon which IAC debug events should occur.
 *
*/
typedef struct {
   unsigned int spr_iac3;          
} SPR_iac3_t;

/*!\brief IAC4: One of four IAC registers used to specify the addresses upon which IAC debug events should occur.
 *
*/
typedef struct {
   unsigned int spr_iac4;          
} SPR_iac4_t;


/*!\brief DBCR0 is an SPR that is used to enable debug modes and events, reset the processor, and control timer
 *operation when debugging.
 *
 * DBCR0 is an SPR that is used to enable debug modes and events, reset the processor, and control timer
 * operation when debugging. DBCR0 can be written from a GPR using mtspr, and can be read into a GPR
 * using mfspr.
 * <pre>
 * Bits     Name  Description
 *  1       IDM   Internal Debug Mode
 *  2:3     RST   Rest
 *  4       ICMP  Instruction Completion Debug Event
 *  5       BRT   Branch Taken Debug Event
 *  6       IRPT  Interrupt Debug Event
 *  7       TRAP  Trap Debug Event
 *  8       IAC1  Instruction Address Compare (IAC) 1 Debug Event
 *  9       IAC2  IAC 2 Debug Event
 * 10       IAC3  IAC 3 Debug Event
 * 11       IAC4  IAC 4 Debug Event
 * 12       DAC1R Data Address Compare (DAC) 1 Read Debug Event
 * 13       DAC1W DAC 1 Write Debug Event
 * 14       DAC2R DAC 2 Read Debug Event
 * 15       DAC 2 Write Debug Event
 * 16       RET   Return Debug Event
 * 17:30          reserved
 * 31       FT    Freeze timers on debug event
 * </pre>
*/
typedef struct {
   unsigned int spr_dbcr0;          
} SPR_dbcr0_t;

/*!\brief DBCR1 is an SPR that is used to configure IAC debug events.
 *
 * DBCR1 is an SPR that is used to configure IAC debug events. DBCR1 can be written from a GPR using
 * mtspr, and can be read into a GPR using mfspr.
 * <pre> 
 * Bits     Name     Description
 * 0:1      IAC1US   Instruction Address Compare (IAC) 1 User/Supervisor
 * 2:3      IAC1ER   IAC 1 Effective/Real
 * 4:5      IAC2US   IAC 2 User/Supervisor
 * 6:7      IAC2ER   IAC 2 Effective/Real
 * 8:9      IAC12M   IAC 1/2 Mode
 * 10:14             reserved
 * 15       IAC12AT  IAC 1/2 Auto-Toggle Enable
 * 16:17    IAC3US   IAC 3 User/Supervisor
 * 18:19    IAC3ER   IAC 3 Effective/Real
 * 20:21    IAC4US   IAC 4 User/Supervisor
 * 22:23    IAC4ER   IAC 4 Effective/Real
 * 24:25    IAC34M   IAC 3/4 Mode
 * 26:30             reserved
 * 31       IAC34AT  IAC3/4 Auto-Toggle Enable
 * </pre>  
*/
typedef struct {
   unsigned int spr_dbcr1;          
} SPR_dbcr1_t;

/*!\brief DBCR2 is an SPR that is used to configure DAC and DVC debug events.
 *
 * DBCR2 is an SPR that is used to configure DAC and DVC debug events. DBCR2 can be written from a GPR
 * using mtspr, and can be read into a GPR using mfspr.
 * <pre>  
 * Bits     Name     Description
 * 0:1      DAC1US   Data Address Compare (DAC) 1 User/Supervisor
 * 2:3      DAC1ER   DAC 1 Effective/Real
 * 4:5      DAC2US   DAC 2 User/Supervisor
 * 6:7      DAC2ER   DAC 2 Effective/Real
 * 8:9      DAC12M   DAC 1/2 Mode
 * 10       DAC12A   DAC 1/2 Asynchronous
 * 11                reserved
 * 12:13    DVC1M    Data Value Compare (DVC) 1 Mode
 * 14:15    DVC2M    DVC 2 Mode
 * 16:19             reserved
 * 20:23    DVC1BE   DVC 1 Byte Enables 0:3
 * 24:27             reserved
 * 28:31    DVC2BE   DVC 2 Byte Enables 0:3  
 * </pre>
 */
typedef struct {
   unsigned int spr_dbcr2;          
} SPR_dbcr2_t;

/*!\brief CCR0: Core Configuration Register 0
 *
 * The CCR0 controls a number of special chip functions, including data cache and auxiliary processor 
 * operation, speculative instruction fetching, trace, and the operation of the cache block touch 
 * instructions.
 * <pre>
 * Bits     Name     Description
 * 0                 reserved
 * 1        PRE      Parity Recoverability Enable
 * 2:3               reserved
 * 4        CRPE     Cache Read Parity Enable
 * 5:9               reserved
 * 10       DSTG     Disable Store Gathering
 * 11       DAPUIB   Disable APU Instruction Broadcast
 * 12:15             reserved
 * 16       DTB      Disable Trace Broadcast
 * 17       GICBT    Guaranteed Instruction Cache Block Touch
 * 18       GDCBT    Guaranteed Data Cache Block Touch
 * 19:22             reserved
 * 23       FLSTA    Force Load/Store Alignment
 * 24:27             reserved
 * 28:29    ICSLC    Instruction Cache Speculative Line Count
 * 30:31    ICSLT    Instruction Cache Speculative Line Threshold
 * </pre>
 */
typedef struct {
   unsigned int spr_ccr0;          
} SPR_ccr0_t;

/*!\brief IVOR0 - Critical Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor0;          
} SPR_ivor0_t;

/*!\brief IVOR1 - Machine Check Interrupt Vector Offset 
 *
*/
typedef struct {
   unsigned int spr_ivor1;          
} SPR_ivor1_t;

/*!\brief IVOR2 - Data Storage Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor2;          
} SPR_ivor2_t;

/*!\brief IVOR3 - Instruction Storage Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor3;          
} SPR_ivor3_t;

/*!\brief IVOR4 - External Input Interrrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor4;          
} SPR_ivor4_t;

/*!\brief IVOR5 - Alignment Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor5;          
} SPR_ivor5_t;

/*!\brief IVOR6 - Program Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor6;          
} SPR_ivor6_t;

/*!\brief IVOR7 - Floating Point Unavailable Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor7;          
} SPR_ivor7_t;

/*!\brief IVOR8 - System Call Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor8;          
} SPR_ivor8_t;

/*!\brief IVOR9 - Auxiliary Processor Unavailable Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor9;          
} SPR_ivor9_t;

/*!\brief IVOR10 - Decrementer Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor10;          
} SPR_ivor10_t;

/*!\brief IVOR11 - Fixed Interval Timer Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor11;          
} SPR_ivor11_t;

/*!\brief IVOR12 - Watchdog Timer Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor12;          
} SPR_ivor12_t;

/*!\brief IVOR13 - Data TLB Error Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor13;          
} SPR_ivor13_t;

/*!\brief IVOR14 - Instruction TLB Error Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor14;          
} SPR_ivor14_t;

/*!\brief IVOR015 - Debug Interrupt Vector Offset
 *
*/
typedef struct {
   unsigned int spr_ivor15;          
} SPR_ivor15_t;

/*!\brief IVPR - provides the high-order 16 bits of the effective address of the interrupt vectors, for all interrupt
 * types.
*/
typedef struct {
   unsigned int spr_ivpr;          
} SPR_ivpr_t;

#endif // Not __ASSEMBLY__ and Not __BGP_HOST_COMPILED__ and Not __MAMBO__

__END_DECLS



#endif // Add nothing below this line

